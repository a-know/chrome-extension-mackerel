const loadavgDesc = "loadvg（ロードアベレージ）は、「実行待ちの（実行キュー内にある）プロセスの数とディスクのI/O待ちのプロセスの数の合計値」です。mackerel-agentでは、/proc/loadavg を読み込み、パースすることで取得しています。\nCPUやディスクさえ空いていれば、すぐにでも実行できるプロセスの数を示す形になります。\n\nこのロードアベレージの値は、システム全体の負荷の状況を表すものとして従来より用いられてきました。ですが、対象のシステムやサービスの特性によっては、瞬間的に処理が集中しロードアベレージの値が増加することもあります。そのような場合において大事なことは、「瞬間的に処理が集中しても、だんだんと平常時の負荷にまで落ち着くことができるかどうか」ということです。つまり、「ロードアベレージがある値以上かどうか」という監視をすることには、それほど意味がありません。\n\n見るべきはその傾向で、もしロードアベレージの値が描くグラフが徐々にでも右肩上がりになっていれば、それは「実際に捌いている処理量（ x ）」と「捌くべき処理の総量（ y ）」が x < y の関係になってしまっているということの現れです。この状態になっていると、放っておくとどんどんと処理待ちプロセスが溜まり、処理されるのが遅れてくる一方なので、根本的な対策を講じる必要があるといえます。\n\nまた、マルチコアCPUが当たり前の今の時代においてその負荷の度合いを見るための指標としては必ずしも相応しいものとはいえないのでは、という議論もあります。"
const cpuDesc = "演算処理装置である CPU の使用率を表しています。mackerel-agentでは、/proc/stat を読み込み、パースすることで取得しています。\nMackerel ではその種類ごとに細分化された使用率を確認することができますが、主に重要なものは以下の4種類のメトリックです。\n\ncpu.user : カーネル以外が使用した時間の割合\ncpu.iowait : I/O待ちによりアイドル状態であった時間の割合\ncpu.system : カーネルが使用した時間の割合\ncpu.idle : I/O待ちがなく、かつCPUがアイドル状態であった時間の割合\n\nCPU使用率が上がるということはそれだけ仕事をしている、ということになるので、この値の高騰がすなわち障害、とは言い切れないケースが多いと思われます。「平常時はどれくらいのCPU使用率を推移するものなのか」という点については日頃から意識しておきましょう。想定されている負荷が発生していない「過剰な低負荷」も問題である場合があります。\n\nサーバーのパフォーマンスが落ちているときにそのボトルネックを探る目的で cpu メトリックを確認すると良い場合があります。\n\ncpu.iowait.percentage が高騰している場合 : ディスクのI/O性能がネック\ncpu.user.percentage が高騰している場合 : カーネル以外（そのサーバで稼働させているアプリケーションなど）のプロセスが原因であり、その処理内容を改善するか、CPUのスペックを挙げることで改善される可能性がある\ncpu.iowait.percentage も cpu.user.percentage も高騰していない場合 : そのCPUで一度に処理が行える数に対して要求の数が大きすぎることがロードアベレージ高騰の原因なので、コア数を増やす・同じ役割のサーバ台数を増やし負荷分散することで改善される可能性がある"
const memoryDesc = "メモリの使用状況です。mackerel-agentでは、/proc/meminfo を読み込み、パースすることで取得しています。\n\n基本的に最近のOSでは、空きメモリの大部分をページキャッシュとして使うようになっている・そしてそれは必要に応じて開放される部分も含まれているので、メモリの使用率・空き容量を監視する際には、その点については注意が必要です。スワップ領域を確保している場合には memory.swap_used の値を注視してもよいかもしれません（スワップすることで大幅にパフォーマンスが悪化するため）。"
const diskDesc = "ディスクの読み書きに関する、IOPS（1秒あたりのI/Oアクセス）の値です。mackerel-agentでは、/proc/diskstats を読み込み、パースすることで取得しています。\n\nディスクのIOPS性能は、製品仕様として明示的に示されていることが殆どです。つまり明確な性能の限界があるなかで、「現状の負荷の占める割合」と「今後発生し得る瞬間的な値の高騰に耐えられるか」という観点が大事です。また、ディスクへの書き込みが主となる役割のサーバー（データベースサーバー、ストレージなど）に対してはより注視すると良いでしょう。\n\nディスク性能の不足はサーバ全体のボトルネックにもなり得ますので、「将来的なサービスの成長に耐えられるかどうか」といったキャパシティプランニング的な見方も必要です。また、平常時の値や1日 / 1週間 / 1ヶ月といった期間におけるトレンドを把握しておくことも重要です。"
const interfaceDesc = "ネットワーク帯域の使用状況です。単位は KB/秒 、tx は送信、 rx は受信です。mackerel-agentでは、/proc/net/dev を読み込み、パースすることで取得しています。\n\nオンプレ環境などでは、そのネットワーク帯域量に明確な上限があるはずなので、その帯域を専有してしまっていないか？（上限帯域量の限界値近くを長時間推移していないか？）という観点でその値やグラフを確認します。\n\nクラウド環境では、上記の観点に加えて、通信そのものに料金が掛かる場合が多いため、その観点での監視を設定しておくのも良いかもしれません。\n\nこのメトリックを特に注視すべきサーバーの種類としては、どうしてもネットワーク転送量が増大しがちなプロキシサーバー・Webサーバー・コンテンツ配信サーバーなどが挙げられます。またロードバランサーなど、パブリックネットワークに面するサーバーの interface を監視しておくことで DOS 攻撃を検知する方法のひとつとしても使えますし、コンテンツ配信サーバーの前に CDN などのキャッシュの仕組みを置いている場合は、コンテンツ配信サーバーの interface の値の増大によりキャッシュの効きの悪化を検知する、などのことにも利用できます。"
const filesystemDesc = "ディスクサイズとその使用量を表すメトリックです。mackerel-agentでは、df コマンドの実行結果をパースすることで取得しています。\n\nパーティションの分割の仕方にもよりますが、空き容量が枯渇するとログなどの書き出しが行えなくなったりして、結果的にそこで動作していたアプリケーションが停止してしまったりするなどの大きな問題が発生する場合がありますので、問題発生時にゆとりを持って作業がおこなえるような閾値や監視設定を施しておきましょう。"

chrome.runtime.onMessage.addListener(function(msg) {
    document.getElementById("metric-loadavg").setAttribute("title", loadavgDesc);
    document.getElementById("metric-cpu").setAttribute("title", cpuDesc);
    document.getElementById("metric-memory").setAttribute("title", memoryDesc);
    document.getElementById("metric-disk").setAttribute("title", diskDesc);
    document.getElementById("metric-interface").setAttribute("title", interfaceDesc);
    document.getElementById("metric-filesystem").setAttribute("title", filesystemDesc);
});
